package api

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"fmt"

	"matcha/internal/core"
	"matcha/internal/driver/api/gen"
	"matcha/internal/driver/api/model"
	"matcha/internal/pkg/password"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUser) (*core.User, error) {
	pwd, err := password.Hash(input.Password)
	if err != nil {
		return nil, err
	}
	u := core.NewUser(input.Username, input.Email, pwd)
	r.users = append(r.users, u)
	return u, nil
}

// CreateIssue is the resolver for the createIssue field.
func (r *mutationResolver) CreateIssue(ctx context.Context, input model.CreateIssue) (*core.Issue, error) {
	i := core.NewIssue(input.Title, input.Description)
	r.issues = append(r.issues, i)
	return i, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*core.User, error) {
	fn := func(u *core.User) bool { return u.ID == id }
	for i := range r.users {
		if u := r.users[i]; fn(u) {
			return u, nil
		}
	}
	return nil, fmt.Errorf("not found: User - user")
}

// Issues is the resolver for the issues field.
func (r *queryResolver) Issues(ctx context.Context) ([]*core.Issue, error) {
	return r.issues, nil
}

// Mutation returns gen.MutationResolver implementation.
func (r *Resolver) Mutation() gen.MutationResolver { return &mutationResolver{r} }

// Query returns gen.QueryResolver implementation.
func (r *Resolver) Query() gen.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
