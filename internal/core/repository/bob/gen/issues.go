// Code generated by BobGen psql v0.22.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package bobgen

import (
	"context"
	"time"

	"github.com/aarondl/opt/omit"
	"github.com/gofrs/uuid/v5"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/im"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
)

// Issue is an object representing the database table.
type Issue struct {
	ID          uuid.UUID `db:"id,pk" `
	Title       string    `db:"title" `
	Description string    `db:"description" `
	CreatedAt   time.Time `db:"created_at" `
}

// IssueSlice is an alias for a slice of pointers to Issue.
// This should almost always be used instead of []*Issue.
type IssueSlice []*Issue

// Issues contains methods to work with the issues table
var Issues = psql.NewTablex[*Issue, IssueSlice, *IssueSetter]("", "issues")

// IssuesQuery is a query on the issues table
type IssuesQuery = *psql.ViewQuery[*Issue, IssueSlice]

// IssuesStmt is a prepared statment on issues
type IssuesStmt = bob.QueryStmt[*Issue, IssueSlice]

// IssueSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type IssueSetter struct {
	ID          omit.Val[uuid.UUID] `db:"id,pk"`
	Title       omit.Val[string]    `db:"title"`
	Description omit.Val[string]    `db:"description"`
	CreatedAt   omit.Val[time.Time] `db:"created_at"`
}

func (s IssueSetter) SetColumns() []string {
	vals := make([]string, 0, 4)
	if !s.ID.IsUnset() {
		vals = append(vals, "id")
	}

	if !s.Title.IsUnset() {
		vals = append(vals, "title")
	}

	if !s.Description.IsUnset() {
		vals = append(vals, "description")
	}

	if !s.CreatedAt.IsUnset() {
		vals = append(vals, "created_at")
	}

	return vals
}

func (s IssueSetter) Overwrite(t *Issue) {
	if !s.ID.IsUnset() {
		t.ID, _ = s.ID.Get()
	}
	if !s.Title.IsUnset() {
		t.Title, _ = s.Title.Get()
	}
	if !s.Description.IsUnset() {
		t.Description, _ = s.Description.Get()
	}
	if !s.CreatedAt.IsUnset() {
		t.CreatedAt, _ = s.CreatedAt.Get()
	}
}

func (s IssueSetter) Apply(q *dialect.UpdateQuery) {
	if !s.ID.IsUnset() {
		um.Set("id").ToArg(s.ID).Apply(q)
	}
	if !s.Title.IsUnset() {
		um.Set("title").ToArg(s.Title).Apply(q)
	}
	if !s.Description.IsUnset() {
		um.Set("description").ToArg(s.Description).Apply(q)
	}
	if !s.CreatedAt.IsUnset() {
		um.Set("created_at").ToArg(s.CreatedAt).Apply(q)
	}
}

func (s IssueSetter) Insert() bob.Mod[*dialect.InsertQuery] {
	vals := make([]bob.Expression, 4)
	if s.ID.IsUnset() {
		vals[0] = psql.Raw("DEFAULT")
	} else {
		vals[0] = psql.Arg(s.ID)
	}

	if s.Title.IsUnset() {
		vals[1] = psql.Raw("DEFAULT")
	} else {
		vals[1] = psql.Arg(s.Title)
	}

	if s.Description.IsUnset() {
		vals[2] = psql.Raw("DEFAULT")
	} else {
		vals[2] = psql.Arg(s.Description)
	}

	if s.CreatedAt.IsUnset() {
		vals[3] = psql.Raw("DEFAULT")
	} else {
		vals[3] = psql.Arg(s.CreatedAt)
	}

	return im.Values(vals...)
}

type issueColumnNames struct {
	ID          string
	Title       string
	Description string
	CreatedAt   string
}

var IssueColumns = struct {
	ID          psql.Expression
	Title       psql.Expression
	Description psql.Expression
	CreatedAt   psql.Expression
}{
	ID:          psql.Quote("issues", "id"),
	Title:       psql.Quote("issues", "title"),
	Description: psql.Quote("issues", "description"),
	CreatedAt:   psql.Quote("issues", "created_at"),
}

type issueWhere[Q psql.Filterable] struct {
	ID          psql.WhereMod[Q, uuid.UUID]
	Title       psql.WhereMod[Q, string]
	Description psql.WhereMod[Q, string]
	CreatedAt   psql.WhereMod[Q, time.Time]
}

func IssueWhere[Q psql.Filterable]() issueWhere[Q] {
	return issueWhere[Q]{
		ID:          psql.Where[Q, uuid.UUID](IssueColumns.ID),
		Title:       psql.Where[Q, string](IssueColumns.Title),
		Description: psql.Where[Q, string](IssueColumns.Description),
		CreatedAt:   psql.Where[Q, time.Time](IssueColumns.CreatedAt),
	}
}

// FindIssue retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindIssue(ctx context.Context, exec bob.Executor, IDPK uuid.UUID, cols ...string) (*Issue, error) {
	if len(cols) == 0 {
		return Issues.Query(
			ctx, exec,
			SelectWhere.Issues.ID.EQ(IDPK),
		).One()
	}

	return Issues.Query(
		ctx, exec,
		SelectWhere.Issues.ID.EQ(IDPK),
		sm.Columns(Issues.Columns().Only(cols...)),
	).One()
}

// IssueExists checks the presence of a single record by primary key
func IssueExists(ctx context.Context, exec bob.Executor, IDPK uuid.UUID) (bool, error) {
	return Issues.Query(
		ctx, exec,
		SelectWhere.Issues.ID.EQ(IDPK),
	).Exists()
}

// PrimaryKeyVals returns the primary key values of the Issue
func (o *Issue) PrimaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

// Update uses an executor to update the Issue
func (o *Issue) Update(ctx context.Context, exec bob.Executor, s *IssueSetter) error {
	return Issues.Update(ctx, exec, s, o)
}

// Delete deletes a single Issue record with an executor
func (o *Issue) Delete(ctx context.Context, exec bob.Executor) error {
	return Issues.Delete(ctx, exec, o)
}

// Reload refreshes the Issue using the executor
func (o *Issue) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Issues.Query(
		ctx, exec,
		SelectWhere.Issues.ID.EQ(o.ID),
	).One()
	if err != nil {
		return err
	}

	*o = *o2

	return nil
}

func (o IssueSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals IssueSetter) error {
	return Issues.Update(ctx, exec, &vals, o...)
}

func (o IssueSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	return Issues.Delete(ctx, exec, o...)
}

func (o IssueSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	IDPK := make([]uuid.UUID, len(o))

	for i, o := range o {
		IDPK[i] = o.ID
	}

	mods = append(mods,
		SelectWhere.Issues.ID.In(IDPK...),
	)

	o2, err := Issues.Query(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.ID != old.ID {
				continue
			}

			*old = *new
			break
		}
	}

	return nil
}
